이번 시간에는 정렬 알고리즘을 배웠다.

데이터 정렬은 데이터 값을 순서대로 재배치하는 것으로 원하는 값을 효율적으로 탐색할 수 있다.

수업 시간에는 선택 정렬, 버블 정렬, 삽입 정렬을 직접 구현해볼 수 있었다.


선택 정렬에서 리스트는 가상의 벽을 기준으로 가상의 벽에 의해 정렬된 리스트와 정렬되지 않은 리스트로 나뉜다.

선택 정렬의 과정은 다음과 같다.

1. 정렬되지 않은 리스트 중에서 가장 작은 값을 찾는다.

2. 1의 과정에서 찾은 값을 정렬되지 않은 리스트의 가장 첫 번째 원소와 교환한다.

3. 가상의 벽을 한 칸 뒤로 옮겨서 검색 범위를 좁힌다.

위의 과정을 패스라고 하면 패스의 총 수행 횟수는 다음과 같다.


데이터의 갯수가 n일 때, 패스의 횟수 :  n-1


위 알고리즘을 구현할 때 반복문이 2개 필요하다.

외부 반복문은 패스를 반복하고

내부 반복문은 정렬되지 않은 리스트에서 가장 작은 값을 찾는다.


버블 정렬도 선택 정렬과 마찬가지로 가상의 벽을 기준으로 정렬된 리스트와 정렬되지 않은 리스트로 나뉜다.

버블 정렬의 과정은 다음과 같다.

1. 정렬되지 않은 리스트의 뒤에서부터 앞으로 이웃한 요소끼리 값을 비교한다.

2. 만약 뒤에 있는 요소가 이웃한 앞에 있는 요소보다 작으면 값을 교환한다.

3. 위 과정을 반복하면 정렬되지 않은 리스트의 가장 작은 값이 맨 앞에 오게 된다.

4. 가상의 벽을 한 칸 뒤로 옮겨서 정렬되지 않은 리스트의 범위를 좁힌다.

패스의 수행 횟수는 선택 정렬과 같다.

반복문을 사용하는 방법도 선택 과정과 같다.


삽입 정렬도 위의 알고리즘들과 같이 가상의 벽을 사용한다. 이 때 가상의 벽은 첫 번째 요소 뒤에 존재한다.

삽입 정렬의 과정은 다음과 같다.

1. 가상의 벽 바로 뒤에 있는 값을 가상의 벽 바로 앞에 있는 값과 비교한다.

2. 가상의 벽 뒤의 값이 크면 가상의 벽을 한 칸 뒤로 옮기고 1을 수행한다.

3. 가상의 벽 뒤의 값이 작으면 그 값을 정렬된 리스트의 값과 뒤에서부터 비교해간다.

4. 이동해야 하는 값보다 작은 값을 발견하면 그 값 뒤에 가상의 벽 바로 뒤의 값을 옮긴다.

5. 가상의 벽을 한 칸 뒤로 옮겨서 검색 범위를 좁힌다.

결국 가상의 벽 바로 뒤의 값을 정렬된 리스트의 알맞은 위치에 삽입하는 것이다.

패스의 횟수와 선택문을 사용하는 방법 역시 위의 알고리즘들과 비슷하다.
